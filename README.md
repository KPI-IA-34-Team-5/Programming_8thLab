# Лабораторна робота №8
## Тема: Вкладені та внутрішні класи
## Виконав(-ли): Ковальчук Станіслав, Сухоручкін Гліб, Янович Марія і Ястремський Богдан
---
### 1. Для чого потрібні вкладені класи (nested classes)?
**Вкладені класи (nested classes)** - це класи, які визначені всередині іншого класу або іншого статичного контексту. Вони можуть бути корисні з кількох причин:

- Логічна групування: Вкладені класи дозволяють групувати класи, які мають логічну залежність між собою. Наприклад, якщо клас є частиною іншого класу і використовується тільки в межах цього класу, його можна вкласти в основний клас.
- Зменшення зовнішньої видимості: Вкладені класи можуть мати доступ до приватних полів та методів основного класу, що зменшує їхню видимість. Це дозволяє зберігати концепцію інкапсуляції та приховувати деталі реалізації.
 Зручність використання: Вкладені класи зручно використовувати, коли клас потрібно використовувати лише в межах одного класу або методу, і вам не потрібно доступатися до нього ззовні.
   Інкапсуляція: Вкладені класи можуть бути використані для реалізації деяких деталей реалізації основного класу, що дозволяє зберігати логіку разом та розділяти її на логічні блоки.
- Покращення читабельності: Вкладені класи можуть полегшити читання коду, особливо коли вони використовуються тільки в межах одного класу, тому що вони розташовані ближче до місця свого використання.

Загалом, вкладені класи допомагають зробити код більш структурованим, організованим та легким для розуміння. Вони використовуються там, де це логічно та зручно для організації програмного коду.

### 2. В чому полягає відмінність між статичними вкладеними (static) та нестатичними внутрішніми (non-static inner) класами? 
Основна відмінність **у їхньому пов'язаному зовнішньому класі та способах доступу до елементів цього класу:

**Статичні вкладені класи (static nested classes):**
- Статичний вкладений клас визначений як статичний у внутрішньому класі.
- Статичний вкладений клас не має доступу до нестатичних полів чи методів зовнішнього класу, він може використовувати лише статичні члени зовнішнього класу.
- Він використовується, коли клас є логічно пов'язаним з іншим класом, але його можна використовувати і без створення екземпляра зовнішнього класу.

**Нестатичні внутрішні класи (non-static inner classes):**
- Нестатичний внутрішній клас визначений як звичайний (non-static) у внутрішньому класі.
- Нестатичний внутрішній клас має доступ до всіх полях та методах зовнішнього класу, навіть до приватних.
- Він може бути використаний тільки після створення екземпляра зовнішнього класу.

Отже, основна відмінність полягає у способі доступу до членів зовнішнього класу та в тому, чи потрібно створювати екземпляр зовнішнього класу для використання внутрішнього класу.

### 3. В яких випадках краще використовувати статичні вкладені (static nested), в яких внутрішні (non-static inner), а в яких звичайні класи?
**Статичні вкладені класи (static nested classes):**
- Використовуйте їх, коли клас пов'язаний з зовнішнім класом, але може існувати самостійно.
- Коли клас не потребує доступу до нестатичних членів зовнішнього класу.
- Це може бути корисно для організації коду та групування пов'язаних класів.

**Нестатичні внутрішні класи (non-static inner classes):**
- Використовуйте їх, коли клас пов'язаний з конкретним об'єктом зовнішнього класу і потребує доступу до його нестатичних членів.
- Коли клас логічно відноситься до зовнішнього класу і може бути використаний тільки в контексті цього класу.

**Звичайні класи:**
- Використовуйте їх, коли клас не пов'язаний з конкретним зовнішнім класом і може існувати незалежно.
- Коли клас може бути використаний в різних контекстах і незалежно від будь-яких інших класів.

Наприклад, якщо ви розробляєте клас автомобіля, можна використовувати статичний вкладений клас для представлення двигуна або нестатичний внутрішній клас для представлення колеса, оскільки двигун і колеса пов'язані з конкретним автомобілем і потребують доступу до його параметрів. 

Однак, якщо у вас є клас "Прямокутник", то краще використовувати звичайний клас, оскільки він може бути використаний в різних контекстах і не пов'язаний з конкретним об'єктом.

### 4. Чи можна (і якщо «так», то яким чином) з середини об’єкту внутрішнього класу звернутися до «this» цього об’єкту або до об’єкту зовнішнього класу? 

Так, за допомогою ключового слова this та ім'ям зовнішнього класу. Це робиться використовуючи спеціальний синтаксис в Java:

Для отримання доступу до об'єкту зовнішнього класу: Внутрішній клас може отримати доступ до об'єкту зовнішнього класу, використовуючи ключове слово OuterClassName.this. Наприклад, якщо зовнішній клас називається Outer, а внутрішній клас називається Inner, то внутрішній клас може отримати доступ до об'єкту зовнішнього класу таким чином: Outer.this.

Для отримання доступу до самого себе ("this" внутрішнього класу): Просто використовуйте ключове слово this всередині внутрішнього класу, як зазвичай.

Ось приклад коду для ілюстрації:
```java
class Outer {
    private int outerField = 10;

    class Inner {
        private int innerField = 20;

        public void accessOuter() {
            // Отримати доступ до об'єкту зовнішнього класу
            System.out.println("Зовнішній клас: outerField = " + Outer.this.outerField);

            // Отримати доступ до самого себе (внутрішнього класу)
            System.out.println("Внутрішній клас: innerField = " + this.innerField);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
        inner.accessOuter();
    }
}
```
У цьому прикладі метод accessOuter() внутрішнього класу Inner отримує доступ до поля outerField зовнішнього класу Outer за допомогою Outer.this.outerField, а також до свого власного поля innerField за допомогою this.innerField.

### 5. Наведіть фрагмент коду для створення:
### - об’єкту вкладеного статичного класу з середини зовнішнього класу;
### - об’єкту вкладеного статичного класу ззовні зовнішнього класу;
### - об’єкту внутрішнього нестатичного класу з середини зовнішнього класу;
### - об’єкту внутрішнього нестатичного класу ззовні зовнішнього класу.

```java
public class Outer {
    private static int outerStaticField = 10;
    private int outerField = 20;

    // Статичний вкладений клас
    static class StaticNested {
        private static int staticNestedField = 30;

        public void display() {
            System.out.println("Static Nested Class: outerStaticField = " + outerStaticField);
            // Звернення до нестатичних полів зовнішнього класу недопустиме
            // System.out.println("Static Nested Class: outerField = " + outerField);
        }
    }

    // Нестатичний внутрішній клас
    class Inner {
        public void display() {
            System.out.println("Inner Class: outerField = " + outerField);
            // Звернення до статичних полів зовнішнього класу допустиме
            System.out.println("Inner Class: outerStaticField = " + outerStaticField);
        }
    }

    public static void main(String[] args) {
        // Створення об'єкту статичного вкладеного класу з середини зовнішнього класу
        StaticNested staticNestedObj = new StaticNested();
        staticNestedObj.display();

        // Створення об'єкту статичного вкладеного класу ззовні зовнішнього класу
        Outer.StaticNested staticNestedObj2 = new Outer.StaticNested();
        staticNestedObj2.display();

        // Створення об'єкту нестатичного внутрішнього класу з середини зовнішнього класу
        Outer outerObj = new Outer();
        Inner innerObj = outerObj.new Inner();
        innerObj.display();

        // Створення об'єкту нестатичного внутрішнього класу ззовні зовнішнього класу
        Outer.Inner innerObj2 = new Outer().new Inner();
        innerObj2.display();
    }
}
```
- Об'єкти створюються для обох типів вкладених класів (статичних та нестатичних) з середини зовнішнього класу Outer та ззовні його.
- Для статичного вкладеного класу StaticNested можна створити об'єкт як з внутрішнього класу, так і ззовні, використовуючи Outer.StaticNested.
- Для нестатичного внутрішнього класу Inner об'єкт створюється з внутрішнього класу за допомогою new Inner(), або ззовні зовнішнього класу за допомогою new Outer().new Inner().

### 6. В чому полягає різниця між локальними та анонімними класами?
Локальні та анонімні класи - це обидва способи внутрішнього класу в Java, але вони мають кілька відмінностей:

**Оголошення:**
- Локальний клас: Оголошується як окремий клас всередині іншого класу або методу, і має ім'я.
- Анонімний клас: Не має власного імені; він оголошується та створюється в тому ж виразі, де він потрібен.

**Використання:**
- Локальний клас: Зазвичай використовується тоді, коли клас повинен бути доступний лише в межах методу або обмеженого контексту.
- Анонімний клас: Використовується для реалізації інтерфейсів або абстрактних класів без створення окремого класу.

**Доступність до контексту:**
- Локальний клас: Має доступ до локальних змінних, параметрів та полів зовнішнього класу.
- Анонімний клас: Має доступ до локальних змінних, але тільки до фіналізованих локальних змінних та параметрів.

**Зовнішній клас:**
- Локальний клас: Може мати доступ до лічильника внутрішнього класу та створювати екземпляри зовнішнього класу.
- Анонімний клас: Не може мати зовнішній клас.

**Спадкування:**
- Локальний клас: Може бути спадкований від інших класів або реалізувати інтерфейси.
- Анонімний клас: Може реалізовувати тільки один інтерфейс або клас.

**Синтаксис:**
- Локальний клас: Оголошується з ключовим словом class.
- Анонімний клас: Оголошується без імені, зазвичай безпосередньо після створення екземпляру інтерфейсу або абстрактного класу.

### 7. Що таке захват змінних (variable capture)?
Захват змінних (variable capture) відбувається, коли локальні змінні або параметри методу, які використовуються всередині лямбда-виразу або анонімного внутрішнього класу, фіксуються (захоплюються) та стають доступними в цих виразах, навіть якщо вони оголошені поза областю видимості лямбда-виразу або внутрішнього класу.

Це дозволяє лямбда-виразам та анонімним класам отримувати доступ до зовнішніх змінних, безпосередньо впливаючи на їх значення. Змінні, які захоплені лямбда-виразом або анонімним класом, повинні бути остаточною або ефективно статично фіналізованою (змінні, які не можуть бути переназначені після ініціалізації), або вони повинні бути фактично фіналізовані, тобто їх значення не повинно змінюватися після захоплення.

Захвачені змінні можуть бути використані всередині лямбда-виразів або анонімних класів, навіть якщо вони були оголошені поза цими конструкціями. Вони стають доступними в області видимості лямбда-виразу або внутрішнього класу і зберігають свої значення на момент створення лямбда-виразу або об'єкту анонімного класу.

Захват змінних дозволяє зберігати стан анонімного об'єкта або лямбда-виразу та оперувати змінними, які знаходяться в зовнішній області видимості.

### 8. Чому з локальних та анонімних класів неможна звертатись до локальних змінних, що змінюють свої значення?
Локальні та анонімні класи в Java можуть звертатися до локальних змінних, але тільки до фіналізованих (final) або ефективно фіналізованих (effectively final) змінних.

Фіналізована змінна - це така змінна, значення якої не може бути змінено після ініціалізації. В Java 8 і пізніших версіях лямбда-вирази та анонімні класи можуть звертатися до локальних змінних, які остаточні або ефективно фіналізовані, оскільки це дозволяє створювати зручні та чисті конструкції коду.

Такий підхід має свої переваги, зокрема полегшує виявлення помилок та дозволяє уникнути певних проблем, пов'язаних зі змінними в багатопотокових середовищах. Крім того, це сприяє покращенню читабельності та підтримки коду.

Таким чином, якщо ви хочете звертатися до локальних змінних з лямбда-виразів або анонімних класів, впевніться, що вони остаточні або ефективно фіналізовані.

### 9. В чому полягає різниця між поняттями «final» та «effectively final»?
Поняття "final" та "effectively final" використовуються в контексті локальних змінних в Java.

**Final (остаточна) змінна:**
- Змінна, оголошена з ключовим словом final, є остаточною.
- Остаточні змінні не можуть бути переназначені після ініціалізації. Однак їх значення може змінюватися, якщо це дозволяє тип даних (наприклад, для масивів, значення елементів може змінюватися, але сам масив не може бути переназначений).
Приклад:
```java
Copy code
final int x = 10;
```

**Effectively final (ефективно фіналізована) змінна:**
- Змінна, яка не оголошена з ключовим словом final, але не переназначається після ініціалізації, вважається ефективно фіналізованою.
- Такі змінні можуть використовуватися всередині лямбда-виразів або анонімних класів в Java 8 і вище.
Вони поводяться подібно до остаточних змінних, оскільки їх значення не змінюється після ініціалізації.
Приклад:
```java
Copy code
int y = 20;
// Змінна 'y' ефективно фіналізована, тому може бути використана всередині лямбда-виразів або анонімних класів.
```
Отже, основна різниця: остаточні змінні є фінальними за своїм станом і не можуть бути змінені, тоді як ефективно фіналізовані змінні, хоча і не оголошені як остаточні, поводяться так само, як остаточні змінні, оскільки їх значення не змінюється після ініціалізації.

---
**Висновок:** у ході цієї лаборатроної роботи ми здобули нові знання та згадали матеріал 1-го семесту у сфері роботи із вкладеними та внутрішніми класами та , змогли відпрацювати це теоретично та на практиці.
